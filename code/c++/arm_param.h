#ifndef ARM_PARAM_H
#define ARM_PARAM_H

#include <DynamixelWorkbench.h>

#define POSITION_OFFSET_DXL4 30	//Смещение позиции 4-го двигателя

#define MX_VEL_UNIT 0.11444 //1 значение требуемой скорости изменяет скорость движения серводвигателя на 0.11444 оборота в минуту для MX

#define DXL_CNT 6	// Число динамикселей в руке
#define GRIPPER 5	//Это число = ID серводвигателя схавата - 1
#define DXL_POSITIONING_END_EFFECTOR 4  // ID последнего двигателя, отвечающего за позиционирование захвата

/* В Arduino IDE есть баг: нельзя хаотично пинговать двигатели разных моделей (MX28->MX64->MX64->M28->AX). Исходя из этого, пингование двигаталей должно быть
   осущественно по-группно (MX28->MX28->MX64->MX64->AX). Но, так как syncWrite на самом деле отправляет данные из массива согласно очередности пингования, а не
   старшести ID, то и сам массив для scynWrite должен заполняться с учетом очередности пингования и, соответственно, группировки двигателей.
*/
//#define DXL_GROUPS 3  //У нас 3 группы двигателей: MX28, MX64 и AX (по факту AX двух моделей (18 и 12), но их можно объединить в одну)
//#define DXL_IN_GROUP 2  //Максимальное количество двигателей в какой-либо группе
/* Высота базы, где находится dxl1 (вращение) учитывается через смещение координат всей конструкции на BASE_HEIGHT вверх.
   Первым звеном считается звено между dxl2 и dxl3.
   Но, так как это звено ломаной формы (фактически правильный треугольник с размерами катетов L1A и L1B), для подобного проблематично
   считать обратную задачу. Оно заменяется на звено L1 (гипотинуза правельного треугольника) + некоторые углы смещения для двигателей
   2 и 3.
*/
#define BASE_HEIGHT 163.5 // Высота базы было 153.5
#define L1A 195.81 // Катет прямоугольника треугольника звена 1
#define L1B 67.36  // Катет прямоугольного треугольника звена 2
#define L1 207.07   // Гипотинуза этого треугольника звена 1
#define L2 134.10  // Звено 2 (ID3- ID4)
#define L3 170.     // Звено 3 (ID4 - середина схвата). Сам захват всегда смотрим вертикально вниз.

#define CARGO_POS_Z 60    // Высота середины схвата для захвата груза
#define ABOVE_CARGO_Z 100   // Высота середины схвата перед опусканием и захватом груза

// Позиция раскрытия самого схвата может меняться от 700 до 350
#define END_EFFECTOR_OPEN 650   // Позиция открытого схвата
#define END_EFFECTOR_CLOSE 495  // Позиция закрытого схава

#define MAX_DIST 400	// Максимальное смещения руки расстояние от центра
#define MIN_DIST 120	// Минимальное расстояние смещения руки от центра

#define MAX_ROT 330		// Максимальный угол поворота руки
#define MIN_ROT 30		// Минимальный угол поворота руки


/* Группировка будет следующая: 1) MX28; 2) MX64; 3) AX
   Соответственно, двигатели будут расположены так: {1,4}, {2,3}, {5,6}
   Важно: SyncWrite будет считать, соответственно, что данные из массива будут отправляться следующим образом:
   [ pos1, pos2, pos3, pos4, pos5, pos6]
   ID:  1     4     2     3     5     6
*/
//extern uint8_t dxl_groups[DXL_GROUPS][DXL_IN_GROUP];

// Массив ID двигателей
extern uint8_t dxl_id[DXL_CNT];

/* Массив угловых смещений.
   Обратная задача была решена для случая, когда позиция MX равная 2048 соответствует углу в 90 градусов. Соответственно,
   это учитывается при переводе из угла поворта в позицию двигателей (все время идет прибавление PI/2 в функции  angle_to_pos к перменной angle).
   С учетом этого, для реализации протокола WS, где 180 градусов это реальная позиция 2048 двигателя, необходимо добавить смещение в -PI/2,
   чтобы скомпенсировать прибавление угла PI/2. Вместе с тем, из-за особенностей работы с первым звеном (меняем Г образную форму на отрезок L1 (гипотинуза),
   появляются углы смещений для двигателей 2 и 3, которые считаются в функции calc_ik_angular_offsets.
*/
extern float ik_angular_offsets[DXL_CNT];

#endif
